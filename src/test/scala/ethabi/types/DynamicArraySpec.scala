package ethabi.types

import org.scalatest.{WordSpec, Matchers}
import ethabi.util.Hex

class DynamicArraySpec extends WordSpec with Matchers {
  import DynamicBytes._
  val bytes = DynamicBytes(Array.fill[Byte](50)(0x24))
  "test bytes[] encode" in {
    val typeInfo = implicitly[TypeInfo[DynamicArray[DynamicBytes]]]
    // 0000000000000000000000000000000000000000000000000000000000000003 +
    // 0000000000000000000000000000000000000000000000000000000000000060 +
    // 00000000000000000000000000000000000000000000000000000000000000c0 +
    // 0000000000000000000000000000000000000000000000000000000000000120 +
    // 0000000000000000000000000000000000000000000000000000000000000032 +
    // 2424242424242424242424242424242424242424242424242424242424242424 +
    // 2424242424242424242424242424242424240000000000000000000000000000 +
    // 0000000000000000000000000000000000000000000000000000000000000032 +
    // 2424242424242424242424242424242424242424242424242424242424242424 +
    // 2424242424242424242424242424242424240000000000000000000000000000 +
    // 0000000000000000000000000000000000000000000000000000000000000032 +
    // 2424242424242424242424242424242424242424242424242424242424242424 +
    // 2424242424242424242424242424242424240000000000000000000000000000
    Hex.bytes2Hex(typeInfo.encode(DynamicArray(Seq.fill[DynamicBytes](3)(bytes)))) shouldBe "0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000"
  }

  "test bytes[] decode" in {
    val encoded = Hex.hex2Bytes("0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000")
    val typeInfo = implicitly[TypeInfo[DynamicArray[DynamicBytes]]]
    val (result, consumed) = typeInfo.decode(encoded, 0)
    result.values.length shouldBe 3
    result.values.map(_.value).foreach(_ shouldBe bytes.value)
    consumed shouldBe encoded.length
  }
}
