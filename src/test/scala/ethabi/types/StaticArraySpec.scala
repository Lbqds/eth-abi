package ethabi.types

import org.scalatest.{WordSpec, Matchers}
import ethabi.util.Hex

class StaticArraySpec extends WordSpec with Matchers {
  val bytes = DynamicBytes(Array.fill[Byte](50)(0x24))
  "test bytes[3] encode" in {
    implicit val length: Int = 3
    val typeInfo = implicitly[TypeInfo[StaticArray[DynamicBytes]]]
    // 0000000000000000000000000000000000000000000000000000000000000060 +
    // 00000000000000000000000000000000000000000000000000000000000000c0 +
    // 0000000000000000000000000000000000000000000000000000000000000120 +
    // 0000000000000000000000000000000000000000000000000000000000000032 +
    // 2424242424242424242424242424242424242424242424242424242424242424 +
    // 2424242424242424242424242424242424240000000000000000000000000000 +
    // 0000000000000000000000000000000000000000000000000000000000000032 +
    // 2424242424242424242424242424242424242424242424242424242424242424 +
    // 2424242424242424242424242424242424240000000000000000000000000000 +
    // 0000000000000000000000000000000000000000000000000000000000000032 +
    // 2424242424242424242424242424242424242424242424242424242424242424 +
    // 2424242424242424242424242424242424240000000000000000000000000000
    Hex.bytes2Hex(typeInfo.encode(StaticArray(Seq.fill[DynamicBytes](3)(bytes)))) shouldBe "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000"
  }

  "test bytes[3] decode" in {
    val encoded = Hex.hex2Bytes("000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003224242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424240000000000000000000000000000")
    implicit val length: Int = 3
    val typeInfo = implicitly[TypeInfo[StaticArray[DynamicBytes]]]
    val (result, consumed) = typeInfo.decode(encoded, 0)
    result.values.length shouldBe length
    result.values.map(_.value).foreach(_ shouldBe bytes.value)
    consumed shouldBe encoded.length
  }

  val address = Address(Array.fill[Byte](20)(0x24))
  "test address[4] encode" in {
    implicit val length: Int = 4
    val typeInfo = implicitly[TypeInfo[StaticArray[Address]]]
    // 0000000000000000000000002424242424242424242424242424242424242424 +
    // 0000000000000000000000002424242424242424242424242424242424242424 +
    // 0000000000000000000000002424242424242424242424242424242424242424 +
    // 0000000000000000000000002424242424242424242424242424242424242424
    Hex.bytes2Hex(typeInfo.encode(StaticArray(Seq.fill[Address](4)(address)))) shouldBe "0000000000000000000000002424242424242424242424242424242424242424000000000000000000000000242424242424242424242424242424242424242400000000000000000000000024242424242424242424242424242424242424240000000000000000000000002424242424242424242424242424242424242424"
  }

  "test address[4] decode" in {
    implicit val length: Int = 4
    val typeInfo = implicitly[TypeInfo[StaticArray[Address]]]
    val encoded = Hex.hex2Bytes("0000000000000000000000002424242424242424242424242424242424242424000000000000000000000000242424242424242424242424242424242424242400000000000000000000000024242424242424242424242424242424242424240000000000000000000000002424242424242424242424242424242424242424")
    val (result, consumed) = typeInfo.decode(encoded, 0)
    result.values.length shouldBe length
    result.values.map(_.value).foreach(_ shouldBe address.value)
    consumed shouldBe encoded.length
  }
}
